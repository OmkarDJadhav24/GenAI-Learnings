<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Part 3: Chunking and Chinking in NLP with Python</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Part 3: Chunking and Chinking in NLP with Python</h1>
</header>
<section data-field="subtitle" class="p-summary">
Chunking and chinking are powerful tools that help NLP models move beyond individual words to understand structured phrases. In this…
</section>
<section data-field="body" class="e-content">
<section name="e12d" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="788f" id="788f" class="graf graf--h3 graf--leading graf--title">Part 3: Chunking and Chinking in NLP with Python</h3><p name="787d" id="787d" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">Chunking and chinking are powerful tools that help NLP models move beyond individual words to understand </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">structured phrases</em></strong><em class="markup--em markup--p-em">. In this hands-on blog, you’ll learn how to extract meaningful word groups from text using NLTK in Python — with visual tree diagrams and simple code.</em></p><p name="aa70" id="aa70" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">What is Chunking?</strong></p><p name="6e20" id="6e20" class="graf graf--p graf-after--p">While tokenizing allows you identify words and sentences, chunking allows you to identify <strong class="markup--strong markup--p-strong">phrases </strong>from POS tagged text-like<strong class="markup--strong markup--p-strong"> </strong>noun phrases (NP), verb phrases (VP), etc.</p><p name="c36f" id="c36f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Phrase: A phrase is word or group of words that’s works as a single unit to perform a </strong>grammatical function. <strong class="markup--strong markup--p-strong">Noun</strong> <strong class="markup--strong markup--p-strong">phrases </strong>are built around a noun.</p><p name="1a9b" id="1a9b" class="graf graf--p graf-after--p">Below are some examples:</p><ul class="postList"><li name="2363" id="2363" class="graf graf--li graf--startsWithDoubleQuote graf-after--p">“A planet”</li><li name="6f98" id="6f98" class="graf graf--li graf--startsWithDoubleQuote graf-after--li">“A tilting planet”</li><li name="63ea" id="63ea" class="graf graf--li graf-after--li">A swiftly tilting planet</li></ul><p name="d008" id="d008" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">&quot;The quick brown fox jumps over the lazy dog.&quot;</code><br> We might chunk <code class="markup--code markup--p-code">&quot;The quick brown fox&quot;</code> as a <strong class="markup--strong markup--p-strong">Noun Phrase (NP)</strong>.</p><p name="462f" id="462f" class="graf graf--p graf-after--p">Chunking uses POS tags to group words and apply chunk tag to those group.</p><p name="6bbb" id="6bbb" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Why Chunking is Useful</strong></p><ul class="postList"><li name="41e9" id="41e9" class="graf graf--li graf-after--p">Groups related words into single units.</li><li name="9784" id="9784" class="graf graf--li graf-after--li">Extracting noun phrases from reviews, articles, or resumes</li><li name="73e6" id="73e6" class="graf graf--li graf-after--li">Prepares data for <strong class="markup--strong markup--li-strong">Named Entity Recognition</strong> (NER).</li><li name="e210" id="e210" class="graf graf--li graf-after--li">Simplifies parsing and pattern recognition.</li><li name="970c" id="970c" class="graf graf--li graf-after--li">Helps extract structured information from unstructured text.</li></ul><p name="95c5" id="95c5" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">How to Do Chunking in NLTK</strong></p><p name="987a" id="987a" class="graf graf--p graf-after--p">Step 1: Tokenize and POS Tag</p><figure name="922a" id="922a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*laN8sYbq_m_nZprUcIz87w.png" data-width="1644" data-height="765" src="https://cdn-images-1.medium.com/max/800/1*laN8sYbq_m_nZprUcIz87w.png"></figure><p name="2391" id="2391" class="graf graf--p graf-after--figure">Step 2: Define a Chunk Grammar</p><figure name="6bf7" id="6bf7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*tUBa_S4il5q4Izglnxf-jA.png" data-width="1644" data-height="64" src="https://cdn-images-1.medium.com/max/800/1*tUBa_S4il5q4Izglnxf-jA.png"></figure><ul class="postList"><li name="bc58" id="bc58" class="graf graf--li graf-after--figure">&lt;DT&gt; → Determiner</li><li name="3202" id="3202" class="graf graf--li graf-after--li">&lt;JJ&gt; → Adjective</li><li name="bcc5" id="bcc5" class="graf graf--li graf-after--li">&lt;NN&gt; → Noun</li><li name="6be8" id="6be8" class="graf graf--li graf-after--li">*, ? → Quantifiers (zero or more, optional)</li></ul><p name="dd8d" id="dd8d" class="graf graf--p graf-after--li">Step 3: Apply the ChunkParser</p><figure name="153e" id="153e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*5kNtccCXftYrerq6vnTk0w.png" data-width="1639" data-height="143" src="https://cdn-images-1.medium.com/max/800/1*5kNtccCXftYrerq6vnTk0w.png"></figure><p name="20e4" id="20e4" class="graf graf--p graf-after--figure">Code Breakdown:</p><p name="f293" id="f293" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">grammar = “NP: {&lt;DT&gt;?&lt;JJ&gt;*&lt;NN&gt;}”</em></strong></p><ul class="postList"><li name="eed7" id="eed7" class="graf graf--li graf-after--p">This means: “Create a chunk called <code class="markup--code markup--li-code">NP</code> (Noun Phrase) that optionally starts with a determiner <code class="markup--code markup--li-code">&lt;DT&gt;</code>, followed by 0 or more adjectives <code class="markup--code markup--li-code">&lt;JJ&gt;</code>, and ends with a noun <code class="markup--code markup--li-code">&lt;NN&gt;</code>&quot;.</li></ul><p name="a1f9" id="a1f9" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">cp = nltk.RegexpParser(grammar)</em></strong></p><ul class="postList"><li name="b421" id="b421" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">RegexpParser</strong> is a class from nltk used to define the chunking rules using regex-like patterns on POS tags.</li><li name="a8b5" id="a8b5" class="graf graf--li graf-after--li">So basically it builts a parser object that knows how to match grammar patterns to sequence of POS tagged tokens.</li></ul><p name="06f7" id="06f7" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">tree = cp.parse(tagged)</em></strong></p><ul class="postList"><li name="8e99" id="8e99" class="graf graf--li graf-after--p">cp.parse(tagged) takes the list of tuples(tagged) and applies the <strong class="markup--strong markup--li-strong">chunking</strong> <strong class="markup--strong markup--li-strong">rules(</strong>grammar<strong class="markup--strong markup--li-strong">)</strong> to find <strong class="markup--strong markup--li-strong">phrases</strong> (chunks) that matches.</li></ul><p name="77b7" id="77b7" class="graf graf--p graf-after--li">The result is a Tree object (like a parse tree) which contains:</p><ul class="postList"><li name="c009" id="c009" class="graf graf--li graf-after--p">Chunked phrases (like a noun phrase NP)</li><li name="e72c" id="e72c" class="graf graf--li graf-after--li">Non-chunked words (left as-is)</li></ul><figure name="cb2a" id="cb2a" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*AbrpJ84it5s3nxykU4XM2g.png" data-width="1597" data-height="527" src="https://cdn-images-1.medium.com/max/800/1*AbrpJ84it5s3nxykU4XM2g.png"></figure><p name="d78d" id="d78d" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">What is Chinking?</strong></p><p name="4fbd" id="4fbd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Chinking</strong> is the opposite of <strong class="markup--strong markup--p-strong">Chunking</strong>. It r<strong class="markup--strong markup--p-strong">emoves specific Part of Speech</strong> from chunk that were previously included.</p><figure name="da48" id="da48" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*psZvlEWceipkQUk564xHfg.png" data-width="1368" data-height="226" src="https://cdn-images-1.medium.com/max/800/1*psZvlEWceipkQUk564xHfg.png"></figure><p name="f2b5" id="f2b5" class="graf graf--p graf-after--figure">Code Breakdown:</p><p name="384a" id="384a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">grammar = r”””<br> NP: {&lt;.*&gt;+} <br> }&lt;VB.*&gt;{ <br>“””</strong></p><ul class="postList"><li name="4208" id="4208" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">NP: {&lt;.*&gt;+} :</strong> Tells that chunk everything (any POS tag, one or more times). So, Initially, it grabs the entire sentence into <strong class="markup--strong markup--li-strong">one big chunk</strong>.</li><li name="a7ba" id="a7ba" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">}&lt;VB.*&gt;{ : </strong>This is a <strong class="markup--strong markup--li-strong">chinking rule </strong>which tells that within any chunk , <strong class="markup--strong markup--li-strong">remove(chink)</strong> any words that have POS tags starting with <strong class="markup--strong markup--li-strong">VB(</strong>verb).</li><li name="9e7c" id="9e7c" class="graf graf--li graf-after--li">For example: VB, VBD, VBG, VBZ, etc.</li></ul><p name="8a90" id="8a90" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">So after chunking everything, we removes(chink) all the verbs from the chunks.</strong></p><figure name="9d26" id="9d26" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*faMQ9rsjxKm16eMStqc8PA.png" data-width="1481" data-height="342" src="https://cdn-images-1.medium.com/max/800/1*faMQ9rsjxKm16eMStqc8PA.png"></figure><p name="b477" id="b477" class="graf graf--p graf-after--figure">Chunking and chinking give you more <strong class="markup--strong markup--p-strong">control</strong> over how text is grouped and interpreted. They’re essential tools for anyone building NLP pipelines or preparing text for <strong class="markup--strong markup--p-strong">semantic analysis</strong>, <strong class="markup--strong markup--p-strong">NER</strong>, or <strong class="markup--strong markup--p-strong">information extraction</strong>.</p><p name="de4e" id="de4e" class="graf graf--p graf-after--p graf--trailing">By mastering them, you’re one step closer to working with <strong class="markup--strong markup--p-strong">real-world language data</strong> like a pro.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@omkarjadhav7522" class="p-author h-card">Omkar Jadhav</a> on <a href="https://medium.com/p/0f335db01973"><time class="dt-published" datetime="2025-05-07T10:57:48.368Z">May 7, 2025</time></a>.</p><p><a href="https://medium.com/@omkarjadhav7522/chunking-and-chinking-in-nlp-with-python-0f335db01973" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on May 7, 2025.</p></footer></article></body></html>